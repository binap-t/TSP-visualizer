<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>2-D TSP Visualizer ver15 — SA / GA / BS (GIF capped & cleaner)</title>
<style>
 body{font-family:Arial,Helvetica,sans-serif;margin:20px;}
 textarea{width:100%;box-sizing:border-box;margin-bottom:10px;font-family:monospace;}
 #canvas{border:1px solid #444;margin-top:10px;background:#fafafa;}
 button{margin-right:6px;}
 input[type=text], input[type=number]{width:120px;margin:0 8px 0 6px;}
 .row{margin:6px 0;}
 #controls{margin-top:8px;display:flex;align-items:center;flex-wrap:wrap;gap:8px;}
 #seekLbl{margin:0 6px;}
 #speedLbl{margin-left:6px;}
 details{margin:10px 0;}
 details > summary{cursor:pointer;font-weight:600;}
 details > div{margin:8px 0 0 0;color:#333;}
 .algo-list{margin:6px 0 0 18px;}
 .algo-list li{margin:3px 0;}
 .hint{color:#555;font-size:0.9em;margin:4px 0 8px;}
 code.inline{background:#f1f1f1;padding:2px 4px;border-radius:4px;}
 .small{font-size:12px;color:#555;margin-left:8px;}
 #gifRow{margin-top:10px;display:flex;align-items:center;gap:8px;flex-wrap:wrap;}
 #gifStatus{font-size:12px;color:#555;}
</style>
</head>
<body>
<h2>📍 2-D TSP Visualizer — SA / GA / BS <small>ver15</small></h2>

<details open>
  <summary>① 概要</summary>
  <div>
    <p>平面上の <strong>N</strong> 個の都市（座標は入力または乱数生成）に対して、各都市を一度ずつ訪れて出発点へ戻る巡回路（ツアー）の総距離を最小化します。距離はユークリッド距離。入力欄の各行は 1 解です。</p>
    <p>各行は <strong>JSON</strong>（<code class="inline">{ "name": "step0001", "solution": "0 3 1 2 ..." }</code>）または <strong>空白区切りの数列</strong>でも可。<code>solution</code> は空白区切りの文字列 / 配列のどちらでもOK。</p>
  </div>
</details>

<details>
  <summary>② 主な機能追加（ver15）</summary>
  <div>
    <ul class="algo-list">
      <li><strong>Play 非ループ</strong>（前版から継続）：最後で停止。</li>
      <li><strong>GIF 改善</strong>：
        <ul>
          <li>フレーム数が 500 を超える場合は<strong>等間隔サンプリングで最大 500 フレーム</strong>に集約（<em>最後のフレームは必ず含む</em>）。</li>
          <li>GIFエンコーダを見直し：<strong>逐次エンコード</strong>で大容量対策、<strong>Disposal Method=2</strong>（背景クリア）で「砂嵐」化を抑制。</li>
        </ul>
      </li>
    </ul>
  </div>
</details>

<div id="topControls">
  <div class="row">
    <label>Seed: <input type="number" id="seed" value="0" step="1"></label>
    <label>N: <input type="number" id="nCities" value="40" min="2" step="1"></label>
    <button id="gen">Generate Cities</button>
  </div>
  <div class="row">
    <label>Steps: <input type="number" id="saSteps" min="1"></label>
    <button id="runSA">Run SA</button>
  </div>
  <div class="row">
    <label>PopSize: <input type="number" id="gaPop" min="2" value="30"></label>
    <label>Generations: <input type="number" id="gaGen" min="1" value="500"></label>
    <button id="runGA">Run GA</button>
  </div>
  <div class="row">
    <label>Width: <input type="number" id="beamW" min="1"></label>
    <button id="runBeam">Run BS</button>
  </div>
</div>

<details id="advanced">
  <summary>Advanced Settings</summary>
  <div class="row">
    <label>SA thinning (k): <input type="number" id="saThin" value="1" min="1" step="1"></label>
    <span class="small">Record every k steps (default: 1 = all)</span>
  </div>
  <div class="row">
    <label>GA thinning (k): <input type="number" id="gaThin" value="1" min="1" step="1"></label>
    <label>GA topK: <input type="number" id="gaTopK" placeholder="all" min="1" step="1"></label>
    <span class="small">Leave topK blank to output all individuals</span>
  </div>
  <div class="row">
    <label>BS topK: <input type="number" id="bsTopK" placeholder="all" min="1" step="1"></label>
    <span class="small">Leave blank to output all W beams</span>
  </div>
</details>

<label style="font-weight:bold">City coordinates</label>
<textarea id="instance" rows="12"></textarea>

<label style="font-weight:bold">Tour solutions (1行=1解 / JSON対応)</label>
<div class="hint">
例:
<pre style="margin:6px 0;background:#f8f8f8;padding:8px;border-radius:6px;">
{ "name": "step0001", "solution": "0 3 1 2 4" }
{ "name": "best_SA", "solution": [0,3,1,2,4] }
</pre>
</div>
<textarea id="solution" rows="8"></textarea>

<div id="controls">
  <button id="prev">◀ Prev</button>
  <input type="range" id="seek" min="1" value="1" style="flex:1;" hidden>
  <span id="seekLbl" hidden>1/1</span>
  <button id="next">Next ▶</button>
  <button id="play">▶ Play</button>
  <label id="speedLbl">Play Speed (sec/step): 
    <input type="range" id="speed" min="0" max="6" value="3" step="1">
    <span id="speedVal">0.1 s/step</span>
  </label>
</div>

<div id="gifRow">
  <button id="saveGif">💾 Save GIF</button>
  <label>GIF fps: <input type="number" id="gifFps" value="10" min="1" max="60" step="1"></label>
  <span id="gifStatus"></span>
</div>

<p id="status" style="font-size:1.1em;font-weight:bold;"></p>
<canvas id="canvas" width="800" height="800"></canvas>

<script>
//=================== state & defaults =============
let N = 40;
const DEFAULTS = {
  saSteps: 5000,
  gaPop: 30,
  gaGen: 500,
  beamW: 20,
  T0: 1000,
  Tend: 1e-3
};

// Log-scale speeds (seconds per step)
const SPEEDS = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1.0];

//=================== RNG helpers =================
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;}} 
function randInt(rng,min,max){return Math.floor(rng()*(max-min+1))+min;}

//=================== GA helpers (unique) ==========
function keyOf(arr){ return arr.join(","); }
function randomTour(rng){
  const t=[...Array(N).keys()];
  for(let i=t.length-1;i>0;i--){const j=randInt(rng,0,i); [t[i],t[j]]=[t[j],t[i]];}
  return t;
}
function mutateSwap(order,rng){
  const i=randInt(rng,0,order.length-1), j=randInt(rng,0,order.length-1);
  [order[i],order[j]]=[order[j],order[i]];
}
function mutateReverse(order,rng){
  const a=randInt(rng,0,order.length-2), b=randInt(rng,a+1,order.length-1);
  for(let k=0;k<(b-a+1)/2;k++) [order[a+k],order[b-k]]=[order[b-k],order[a+k]];
}
function makeInitialUniquePopulation(popSize,rng){
  const pop=[]; const seen=new Set();
  let tries=0, limit=popSize*50;
  while(pop.length<popSize && tries<limit){
    let t=randomTour(rng);
    let k=keyOf(t);
    if(seen.has(k)){
      for(let attempt=0; attempt<5 && seen.has(k); attempt++){
        mutateSwap(t,rng);
        k=keyOf(t);
      }
    }
    if(!seen.has(k)){ pop.push(t); seen.add(k); }
    tries++;
  }
  while(pop.length<popSize){
    let base = pop[randInt(rng,0,pop.length-1)].slice();
    mutateSwap(base,rng); mutateReverse(base,rng);
    const k = keyOf(base);
    if(!seen.has(k)){ pop.push(base); seen.add(k); }
  }
  return pop;
}
function ensureUniqueChild(child, seen, rng){
  let cand = child.slice();
  let k = keyOf(cand);
  if(!seen.has(k)) return cand;
  for(let i=0;i<10;i++){
    cand = child.slice();
    if(i%2===0) mutateSwap(cand,rng); else mutateReverse(cand,rng);
    k = keyOf(cand);
    if(!seen.has(k)) return cand;
  }
  return null;
}
function fillRandomUniques(next, seen, targetSize, rng){
  while(next.length<targetSize){
    let t = randomTour(rng);
    let k = keyOf(t);
    if(seen.has(k)) continue;
    seen.add(k); next.push(t);
  }
}

//=================== globals ======================
let cities=[], solutionsArr=[], solutionNames=[], currentIdx=0, playTimer=null;

//=================== city generation ==============
function generateCities(){
  const seedNum = parseInt(document.getElementById("seed").value);
  const nInput = parseInt(document.getElementById("nCities").value);
  N = Number.isFinite(nInput) && nInput>=2 ? nInput : N;
  document.getElementById("nCities").value = N;
  const seed = Number.isFinite(seedNum) ? seedNum : Math.floor(Math.random()*2**32);
  const rng=mulberry32(seed);
  cities=[];
  for(let i=0;i<N;i++){
    cities.push({x:50+randInt(rng,0,700), y:50+randInt(rng,0,700)});
  }
  const instTxt=[N.toString()].concat(cities.map(p=>p.x+" "+p.y)).join("\n");
  document.getElementById("instance").value=instTxt;

  const tour=[...Array(N).keys()];
  for(let i=N-1;i>0;i--){const j=randInt(rng,0,i);[tour[i],tour[j]]=[tour[j],tour[i]];}
  const initLine = JSON.stringify({name:"step0001", solution: tour.join(" ")});
  document.getElementById("solution").value = initLine;
}

//=================== parsing ======================
function parseInstance(txt){
  const lines=txt.replace(/\r/g,"").trim().split(/\n+/).filter(l=>l!=="");
  if(lines.length<1) return [];
  const n=parseInt(lines[0].trim(),10);
  if(!Number.isFinite(n) || n<2){alert("先頭行に N(>=2) を書いてください");return [];}
  if(lines.length!==n+1){alert(`座標行数が不足/過多です（期待: ${n} 行）`);return [];}
  const pts=[];
  for(let i=1;i<=n;i++){
    const parts=lines[i].trim().split(/\s+/);
    if(parts.length<2){alert("座標行の形式が不正です");return [];}
    const x=Number(parts[0]), y=Number(parts[1]);
    if(!(Number.isFinite(x)&&Number.isFinite(y))){alert("座標に数値以外が含まれています");return [];}
    pts.push({x,y});
  }
  N = n;
  document.getElementById("nCities").value = N;
  return pts;
}

function coerceOrder(val){
  if(Array.isArray(val)) return val.map(Number);
  if(typeof val==="string") return val.replace(/,/g," ").trim().split(/\s+/).map(Number);
  return null;
}

function parseSolutions(text){
  const lines = text.replace(/\r/g,"").split(/\n/);
  const out = [];
  const names = [];
  let auto = 1;
  for(const line of lines){
    const trimmed = line.trim();
    if(!trimmed) continue;

    let arr=null, name=null;

    if(trimmed.startsWith("{")){
      try{
        const obj = JSON.parse(trimmed);
        arr = coerceOrder(obj.solution);
        if(arr) name = (typeof obj.name==="string" && obj.name.trim()) ? obj.name.trim() : null;
      }catch(e){
      }
    }
    if(!arr){
      const tmp = trimmed.replace(/,/g," ").split(/\s+/).map(Number);
      const ok = tmp.length>=1 && tmp.length<=N && tmp.every(v=>Number.isInteger(v)&&v>=0&&v<N);
      if(ok){ arr = tmp; }
    }

    if(arr){
      const ok = arr.length>=1 && arr.length<=N && arr.every(v=>Number.isInteger(v)&&v>=0&&v<N);
      if(ok){
        out.push(arr.slice());
        if(!name){ name = "step"+String(auto).padStart(4,"0"); }
        names.push(name);
        auto++;
      }
    }
  }
  solutionNames = names;
  return out;
}

//=================== distance & drawing ===========
function dist(a,b){const dx=a.x-b.x,dy=a.y-b.y;return Math.hypot(dx,dy);}
function pathLength(order, closed){
  if(!order || order.length===0) return 0;
  let len=0;
  for(let i=0;i<order.length-1;i++){
    const a=cities[order[i]], b=cities[order[i+1]];
    len+=dist(a,b);
  }
  if(closed && order.length>1){
    const a=cities[order[order.length-1]], b=cities[order[0]];
    len+=dist(a,b);
  }
  return len;
}
function draw(order, closed){
  const canvas=document.getElementById("canvas");
  const ctx=canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!order||order.length===0) return;

  ctx.lineWidth=2; ctx.strokeStyle = closed ? "#0066ff" : "#008a00";
  ctx.beginPath();
  const start=cities[order[0]];
  ctx.moveTo(start.x,start.y);
  for(let i=1;i<order.length;i++){const p=cities[order[i]];ctx.lineTo(p.x,p.y);}
  if(closed && order.length>1){ ctx.lineTo(start.x,start.y); }
  ctx.stroke();

  ctx.fillStyle="#ff6600";
  for(const p of cities){ctx.beginPath();ctx.arc(p.x,p.y,4,0,Math.PI*2);ctx.fill();}

  ctx.fillStyle="#000"; ctx.font="11px monospace";
  for(let i=0;i<order.length;i++){const p=cities[order[i]];ctx.fillText(order[i],p.x+5,p.y-5);}
}

//=================== helpers ======================
function hasDuplicates(arr){
  const seen=new Set();
  for(const v of arr){ if(seen.has(v)) return true; seen.add(v); }
  return false;
}

//=================== UI flow ======================
function updateSeekUI(){
  const seek=document.getElementById("seek");
  const lbl=document.getElementById("seekLbl");
  if(solutionsArr.length<=1){seek.hidden=true;lbl.hidden=true;}
  else{seek.hidden=false;lbl.hidden=false;seek.max=solutionsArr.length;seek.value=currentIdx+1;lbl.textContent=`${currentIdx+1}/${solutionsArr.length}`;}
}
function composeStatus(order, complete, len){
  const notes=[];
  if(!complete) notes.push(`incomplete ${order.length}/${N}`);
  if(hasDuplicates(order)) notes.push("has duplicates");
  const noteStr = notes.length? " ("+notes.join("; ")+")" : "";
  const nm = solutionNames[currentIdx] ? ` — ${solutionNames[currentIdx]}` : "";
  return `Step ${currentIdx+1}/${solutionsArr.length}${nm} — Tour length: ${len}${noteStr}`;
}
function load(idx){
  if(!cities.length||solutionsArr.length===0) return;
  currentIdx=(idx+solutionsArr.length)%solutionsArr.length;
  const order=solutionsArr[currentIdx];
  const complete = (order.length===N);
  const len = pathLength(order, complete).toFixed(2);
  document.getElementById("status").textContent=composeStatus(order, complete, len);
  draw(order, complete);
  updateSeekUI();
}

function stopPlay(){
  if(playTimer){clearInterval(playTimer);playTimer=null;}
  document.getElementById("play").textContent="▶ Play";
}
function startPlay(){
  if(solutionsArr.length<=1) return;
  const idx = +document.getElementById("speed").value; // 0..6
  const perStepMs = Math.max(5, SPEEDS[idx]*1000);
  playTimer=setInterval(()=>{
    if(currentIdx+1 >= solutionsArr.length){
      stopPlay(); // non-loop
      return;
    }
    load(currentIdx+1);
  }, perStepMs);
  document.getElementById("play").textContent="⏸ Pause";
  updateSpeedLabel();
}
function updateSpeedLabel(){
  const idx = +document.getElementById("speed").value;
  document.getElementById("speedVal").textContent = `${SPEEDS[idx]} s/step`;
}

//================== SA / GA / BS ==================
function runSA(){
  if(!cities.length){alert("先に都市を生成するか City coordinates を入力してください");return;}
  const stepsInput = parseInt(document.getElementById("saSteps").value);
  const steps = Number.isFinite(stepsInput)&&stepsInput>0 ? stepsInput : DEFAULTS.saSteps;

  const thinInput = parseInt(document.getElementById("saThin").value);
  const thin = Number.isFinite(thinInput) && thinInput>=1 ? thinInput : 1;

  let order=[...Array(N).keys()];
  let bestLen=pathLength(order,true);
  let bestOrder=order.slice();

  const T0 = DEFAULTS.T0, Tend = DEFAULTS.Tend;
  const rng=mulberry32(1234567);

  const record=[];
  const names=[];

  record.push(order.slice());
  names.push(`step${String(1).padStart(4,"0")}`);

  let currLen=bestLen, stepNo=1;

  for(let iter=1;iter<=steps;){
    const i=randInt(rng,0,N-1), j=randInt(rng,0,N-1);
    if(i===j) continue;
    const a=Math.min(i,j), b=Math.max(i,j);
    const aPrev=order[(a-1+N)%N], aCity=order[a], bCity=order[b], bNext=order[(b+1)%N];
    const delta =  dist(cities[aPrev],cities[bCity]) + dist(cities[aCity],cities[bNext])
                 - dist(cities[aPrev],cities[aCity]) - dist(cities[bCity],cities[bNext]);

    const T = T0 * Math.pow(Tend/T0, iter/steps);
    if(delta<0 || Math.exp(-delta/T) > Math.random()){
      for(let k=0;k<(b-a+1)/2;k++) [order[a+k],order[b-k]]=[order[b-k],order[a+k]];
      currLen += delta;
      if(currLen<bestLen){bestLen=currLen; bestOrder=order.slice();}
    }
    stepNo++;
    if(stepNo % thin === 0){
      record.push(order.slice());
      names.push(`step${String(stepNo).padStart(4,"0")}`);
    }
    iter++;
  }

  record.push(bestOrder.slice());
  names.push("final_SA");

  writeSolutionsToTextarea(record, names);
  syncFromSolutionField(true);
}

function orderCrossover(p1,p2,rng){
  const n=p1.length;
  const child=new Array(n).fill(-1);
  const a=randInt(rng,0,n-2), b=randInt(rng,a+1,n-1);
  for(let i=a;i<=b;i++) child[i]=p1[i];
  let idx=(b+1)%n;
  for(let k=0;k<n;k++){
    const gene=p2[(b+1+k)%n];
    if(!child.includes(gene)){child[idx]=gene; idx=(idx+1)%n;}
  }
  return child;
}
function runGA(){
  if(!cities.length){alert("先に都市を生成するか City coordinates を入力してください");return;}
  const rng=mulberry32(7654321);
  const popInput = parseInt(document.getElementById("gaPop").value);
  const genInput = parseInt(document.getElementById("gaGen").value);
  const popSize = Number.isFinite(popInput)&&popInput>=2 ? popInput : DEFAULTS.gaPop;
  const generations = Number.isFinite(genInput)&&genInput>=1 ? genInput : DEFAULTS.gaGen;
  const mutationProb=0.2;

  const thinInput = parseInt(document.getElementById("gaThin").value);
  const thin = Number.isFinite(thinInput) && thinInput>=1 ? thinInput : 1;
  const topKInput = parseInt(document.getElementById("gaTopK").value);
  const topK = Number.isFinite(topKInput) && topKInput>=1 ? Math.min(topKInput, popSize) : popSize; // default all

  let population = makeInitialUniquePopulation(popSize, rng);

  const record=[];
  const names=[];
  let globalBest=null, globalBestLen=Infinity;

  for(let gen=0;gen<generations;gen++){
    const scored=population.map(t=>({tour:t,len:pathLength(t,true)})).sort((a,b)=>a.len-b.len);

    if((gen+1) % thin === 0){
      const K = Math.min(topK, scored.length);
      for(let r=0;r<K;r++){
        record.push(scored[r].tour.slice());
        names.push(`gen${String(gen+1).padStart(4,"0")}top${String(r+1).padStart(4,"0")}`);
      }
    }

    if(scored[0].len < globalBestLen){ globalBest = scored[0].tour.slice(); globalBestLen = scored[0].len; }

    const next=[]; const seen=new Set();
    next.push(scored[0].tour.slice()); // elitism
    seen.add(keyOf(next[0]));

    const tournament=(k)=>{
      let best=null;
      for(let i=0;i<k;i++){
        const cand=scored[randInt(rng,0,scored.length-1)];
        if(best===null||cand.len<best.len) best=cand;
      }
      return best.tour;
    };

    let safety=0, limit=popSize*100;
    while(next.length<popSize && safety<limit){
      safety++;
      const p1=tournament(5), p2=tournament(5);
      let child=orderCrossover(p1,p2,rng);
      if(Math.random()<mutationProb) mutateSwap(child,rng);
      let uniq=ensureUniqueChild(child, seen, rng);
      if(uniq){
        seen.add(keyOf(uniq));
        next.push(uniq);
      }
    }
    if(next.length<popSize){
      fillRandomUniques(next, seen, popSize, rng);
    }
    population=next;
  }

  if(globalBest){ record.push(globalBest.slice()); names.push("final_GA"); }

  writeSolutionsToTextarea(record, names);
  syncFromSolutionField(true);
}

function runBeam(){
  if(!cities.length){alert("先に都市を生成するか City coordinates を入力してください");return;}
  const wInput = parseInt(document.getElementById("beamW").value);
  const W = Number.isFinite(wInput)&&wInput>=1 ? wInput : DEFAULTS.beamW;

  const topKInput = parseInt(document.getElementById("bsTopK").value);
  const TOP = Number.isFinite(topKInput) && topKInput>=1 ? Math.min(topKInput, W) : W; // default all W

  let beam=[{path:[0], cost:0}]; // start at 0
  const record=[];
  const names=[];

  for(let step=0;step<N;step++){
    const K = Math.min(TOP, beam.length);
    for(let r=0;r<K;r++){
      record.push(beam[r].path.slice());
      names.push(`step${String(step+1).padStart(4,"0")}top${String(r+1).padStart(4,"0")}`);
    }

    if(step===N-1) break;

    const candidates=[];
    beam.forEach(state=>{
      const used=new Set(state.path);
      const last=state.path[state.path.length-1];
      for(let v=0;v<N;v++){
        if(!used.has(v)){
          const newCost=state.cost + dist(cities[last], cities[v]);
          const newPath=state.path.concat(v);
          candidates.push({path:newPath, cost:newCost});
        }
      }
    });
    candidates.sort((a,b)=>a.cost-b.cost);
    beam=candidates.slice(0,W);
  }

  if(beam.length){
    record.push(beam[0].path.slice());
    names.push("final_BS");
  }

  writeSolutionsToTextarea(record, names);
  syncFromSolutionField(true);
}

//================== GIF export (improved) =========
function buildPalette256(){
  // 8x8x4 cube = 256 colors
  const pal = new Uint8Array(256*3);
  let idx=0;
  for(let r=0;r<8;r++){
    for(let g=0; g<8; g++){
      for(let b=0; b<4; b++){
        pal[idx++] = Math.round(r*255/7);
        pal[idx++] = Math.round(g*255/7);
        pal[idx++] = Math.round(b*255/3);
      }
    }
  }
  return pal;
}
function rgbToIndex(r,g,b){
  const ri = r>>>5; // 0..7
  const gi = g>>>5; // 0..7
  const bi = b>>>6; // 0..3
  return (ri<<5) | (gi<<2) | bi;
}
function imageDataToIndexed(img){
  const {data, width, height} = img;
  const out = new Uint8Array(width*height);
  let p=0;
  for(let i=0;i<data.length;i+=4){
    out[p++] = rgbToIndex(data[i], data[i+1], data[i+2]);
  }
  return out;
}
function writeShortLE(arr, v){ arr.push(v & 0xFF, (v>>8)&0xFF); }
function lzwEncode(minCodeSize, indices){
  const CLEAR = 1<<minCodeSize;
  const EOI = CLEAR + 1;
  let codeSize = minCodeSize + 1;
  let nextCode = EOI + 1;
  const MAX_CODE = 4095;

  const outputBytes = [];
  let curByte = 0;
  let bitPos = 0;
  function output(code){
    curByte |= (code << bitPos);
    bitPos += codeSize;
    while(bitPos >= 8){
      outputBytes.push(curByte & 0xFF);
      curByte >>= 8;
      bitPos -= 8;
    }
  }
  function flush(){
    if(bitPos>0){
      outputBytes.push(curByte & 0xFF);
      curByte = 0; bitPos=0;
    }
  }

  const dict = new Map();
  function resetDict(){
    dict.clear();
    codeSize = minCodeSize + 1;
    nextCode = EOI + 1;
  }

  output(CLEAR);

  let prev = indices[0];
  for(let i=1;i<indices.length;i++){
    const k = indices[i];
    const key = (prev<<8) | k;
    if(dict.has(key)){
      prev = dict.get(key);
    }else{
      output(prev);
      if(nextCode <= MAX_CODE){
        dict.set(key, nextCode++);
        if(nextCode === (1<<codeSize) && codeSize<12){ codeSize++; }
      }else{
        output(CLEAR);
        resetDict();
      }
      prev = k;
    }
  }
  output(prev);
  output(EOI);
  flush();

  // sub-blocks
  const blocks = [];
  for(let i=0;i<outputBytes.length; i+=255){
    const size = Math.min(255, outputBytes.length - i);
    blocks.push(size, ...outputBytes.slice(i, i+size));
  }
  blocks.push(0); // terminator
  return new Uint8Array(blocks);
}

function GifWriter(width, height, delayCS){
  this.bytes = [];
  this.width = width;
  this.height = height;
  this.delayCS = delayCS;
  this.pal = buildPalette256();
  // Header + LSD + GCT
  const b = this.bytes;
  b.push(0x47,0x49,0x46,0x38,0x39,0x61); // GIF89a
  writeShortLE(b, width);
  writeShortLE(b, height);
  const gctFlag = 1<<7;
  const colorRes = 7<<4;
  const sortFlag = 0<<3;
  const gctSize = 7; // 256
  b.push(gctFlag | colorRes | sortFlag | gctSize);
  b.push(0); // bg index
  b.push(0); // aspect
  for(let i=0;i<this.pal.length;i++) b.push(this.pal[i]);
}
GifWriter.prototype.addFrame = function(indices){
  const b = this.bytes;
  // Graphic Control Extension (disposal=2: restore to background)
  b.push(0x21, 0xF9, 0x04);
  const disposal2 = 0x08; // bits 2..4 = 2
  const packed = disposal2; // no transparency
  b.push(packed);
  writeShortLE(b, this.delayCS);
  b.push(0x00); // transparent color idx
  b.push(0x00); // terminator

  // Image Descriptor
  b.push(0x2C);
  writeShortLE(b, 0); writeShortLE(b, 0);
  writeShortLE(b, this.width); writeShortLE(b, this.height);
  b.push(0x00); // no local color table

  // Image Data
  const minCodeSize = 8;
  b.push(minCodeSize);
  const lzw = lzwEncode(minCodeSize, indices);
  for(let i=0;i<lzw.length;i++) b.push(lzw[i]);
};
GifWriter.prototype.finish = function(){
  this.bytes.push(0x3B); // trailer
  return new Uint8Array(this.bytes);
};

function chooseFrameIndices(total, cap){
  if(total <= cap){
    return Array.from({length: total}, (_,i)=>i);
  }
  const idx=[];
  const step = (total-1)/(cap-1);
  for(let k=0;k<cap-1;k++){
    const v = Math.floor(k*step);
    if(idx.length===0 || v!==idx[idx.length-1]) idx.push(v);
  }
  if(idx[idx.length-1] !== total-1) idx.push(total-1);
  return idx;
}

async function saveGif(){
  if(!cities.length || !solutionsArr.length){ alert("まずインスタンスと解を用意してください"); return; }
  stopPlay();
  const fps = Math.max(1, Math.min(60, parseInt(document.getElementById("gifFps").value)||10));
  const delayCS = Math.round(100 / fps);
  const src = document.getElementById("canvas");
  const statusEl = document.getElementById("status");

  // Compose status + canvas into one offscreen canvas
  const padTop = 26;
  const w = src.width, h = src.height + padTop;
  const off = document.createElement("canvas");
  off.width = w; off.height = h;
  const octx = off.getContext("2d");

  const total = solutionsArr.length;
  const cap = 500;
  const indicesList = chooseFrameIndices(total, cap);
  const writer = new GifWriter(w, h, delayCS);

  document.getElementById("gifStatus").textContent = `Encoding GIF: 0/${indicesList.length} frames...`;

  for(let ii=0; ii<indicesList.length; ii++){
    const i = indicesList[ii];
    load(i);
    // compose
    octx.fillStyle = "#ffffff";
    octx.fillRect(0,0,w,h);
    octx.fillStyle = "#000000";
    octx.font = "bold 14px monospace";
    octx.textBaseline = "top";
    octx.fillText(statusEl.textContent, 6, 6);
    octx.drawImage(src, 0, padTop);
    const img = octx.getImageData(0,0,w,h);
    const idxs = imageDataToIndexed(img);
    writer.addFrame(idxs);
    if(ii%20===0) await new Promise(r=>setTimeout(r,0));
    if(ii%10===0) document.getElementById("gifStatus").textContent = `Encoding GIF: ${ii+1}/${indicesList.length} frames...`;
  }

  const bytes = writer.finish();
  const blob = new Blob([bytes], {type:"image/gif"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  const ts = new Date().toISOString().replace(/[:.]/g,"-");
  a.href = url;
  a.download = `tsp_visualizer_${ts}.gif`;
  a.click();
  URL.revokeObjectURL(url);
  document.getElementById("gifStatus").textContent = `Saved ${indicesList.length} frames @${fps}fps (capped at 500)`;
}

//================== controls/events ===============
function writeSolutionsToTextarea(record, names){
  const lines = record.map((arr, i)=>{
    const name = (names && names[i]) ? names[i] : ((solutionNames[i] && solutionNames[i].trim()) ? solutionNames[i] : `step${String(i+1).padStart(4,"0")}`);
    return JSON.stringify({name, solution: arr.join(" ")});
  }).join("\n");
  document.getElementById("solution").value = lines;
}
function syncFromSolutionField(resetIdx=true){
  const parsedCities = parseInstance(document.getElementById("instance").value);
  if(parsedCities.length){ cities = parsedCities; }
  solutionsArr = parseSolutions(document.getElementById("solution").value);
  if(!solutionsArr.length){ document.getElementById("status").textContent=""; updateSeekUI(); draw(); return; }
  if(resetIdx) currentIdx = 0;
  if(currentIdx >= solutionsArr.length) currentIdx = solutionsArr.length-1;
  load(currentIdx);
}

document.getElementById("gen").onclick = ()=>{
  stopPlay();
  generateCities();
  syncFromSolutionField(true);
};
document.getElementById("runSA").onclick=()=>{stopPlay(); runSA();};
document.getElementById("runGA").onclick=()=>{stopPlay(); runGA();};
document.getElementById("runBeam").onclick=()=>{stopPlay(); runBeam();};

document.getElementById("prev").onclick=()=>{stopPlay(); if(solutionsArr.length) load(currentIdx-1);};
document.getElementById("next").onclick=()=>{stopPlay(); if(solutionsArr.length) load(currentIdx+1);};
document.getElementById("seek").oninput=e=>{stopPlay(); load(+e.target.value-1);};

document.getElementById("play").onclick=()=>{
  if(!playTimer){ startPlay(); } else { stopPlay(); }
};
document.getElementById("speed").oninput=e=>{
  updateSpeedLabel();
  if(playTimer){ stopPlay(); startPlay(); }
};

document.getElementById("saveGif").onclick=()=>{ saveGif(); };

document.getElementById("solution").addEventListener("input", ()=>{
  stopPlay();
  syncFromSolutionField(false);
});
document.getElementById("instance").addEventListener("input", ()=>{
  stopPlay();
  const parsedCities = parseInstance(document.getElementById("instance").value);
  if(parsedCities.length){ cities = parsedCities; }
  syncFromSolutionField(false);
});

//================== bootstrap =====================
function initDefaults(){
  document.getElementById("saSteps").value = DEFAULTS.saSteps;
  document.getElementById("gaPop").value   = DEFAULTS.gaPop;
  document.getElementById("gaGen").value   = DEFAULTS.gaGen;
  document.getElementById("beamW").value   = DEFAULTS.beamW;
  updateSpeedLabel();
}
initDefaults();
generateCities();
syncFromSolutionField(true);
</script>
</body>
</html>
